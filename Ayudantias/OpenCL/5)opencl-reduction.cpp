// Compilation as: gcc -framework OpenCL opencl-sum.cpp

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#ifdef __APPLE__
#include <OpenCL/opencl.h>
#else
#define CL_TARGET_OPENCL_VERSION 120
#include <CL/cl.h>
#endif

// Functionality to print error messages
void exitmsg(const char *msg){ printf("ERROR: %s\n", msg); exit(EXIT_FAILURE); }
void checkError(cl_int status, const char *msg) { if (status != CL_SUCCESS) exitmsg(msg); }

// Function that calculates the sum of a vector.
const char *src =
"__kernel void reduce(                                        \n"
"    __global int *vec,                                       \n"
"    __const unsigned int n,                                  \n"
"    __global int* partial_sums)                              \n"
"{                                                            \n"
"    int group_size = get_local_size(0);                      \n"
"    int local_id = get_local_id(0);                          \n"
"    int group_id = get_group_id(0);                          \n"
"    int global_id = get_global_id(0);                        \n"
"    if (local_id == 0) {                                     \n"
"        int sum = 0;                                         \n"
"        for (int i = 0; i < group_size; i++) {               \n"
"            sum += vec[global_id+i];                         \n"
"        }                                                    \n"
"        partial_sums[group_id] = sum;                        \n"
"    }                                                        \n"
"}                                                            \n"
;

int main(int argc, char *argv[])
{
    // Create data on the host
    const unsigned int size_vector = 100;
    printf("Size of sum: %i\n", size_vector);
    int *vec_orig = (int *)malloc(sizeof(int) * size_vector);
    for (int i = 0; i < size_vector; i++) {
        vec_orig[i] = i;
    }

    // Specify the size of each workgroup.
    const unsigned int size_group = 16;
    int num_groups = size_vector / size_group;
    if (num_groups * size_group != size_vector){
        num_groups += 1;
    }

    // Pad the vector with zeros at the end.
    const unsigned int n = num_groups * size_group;
    int n_pad = n - size_vector;
    printf("Size of vector: %i\n", n);
	int *h_vec = (int *)malloc(sizeof(int) * n);
    for (int i = 0; i < size_vector; i++) {
        h_vec[i] = vec_orig[i];
    }
    for (int i = size_vector; i < n; i++) {
        h_vec[i] = 0;
    }

    // Print the values of the vector.
    printf("Vector: ");
    for (int i = 0; i < n; i++) {
        printf("%i  ", h_vec[i]);
    }
    printf("\n");

    // Allocate the OpenCL variables for the heterogeneous processors
    cl_int err;
    cl_platform_id platform;
    cl_device_id device;
    cl_context context;
    cl_command_queue commands;

    // Boilerplate functionality
    err = clGetPlatformIDs(1, &platform, NULL);
    err = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 1, &device, NULL);
    cl_context_properties cps[3] = { CL_CONTEXT_PLATFORM, (cl_context_properties)platform, 0 };
    context = clCreateContext(cps, 1, &device, NULL, NULL, &err);
    commands = clCreateCommandQueue(context, device, 0, &err);
    
    // Allocate memory on the device
    cl_mem d_vec = clCreateBuffer(context, CL_MEM_READ_ONLY, n * sizeof(int), NULL, &err);

    // Initialise on device memory
    err = clEnqueueWriteBuffer(commands, d_vec, CL_TRUE, 0, n * sizeof(int), (void*)h_vec, 0, NULL, NULL);

    // Create the compute program from the source buffer
    cl_program program = clCreateProgramWithSource(context, 1, (const char **)&src, NULL, &err);
    checkError(err, "Creating program");

    // Build the program. If things go wrong, OpenCL provides a method that allows
    // extraction of the error message generated by the device code compiler.
    err = clBuildProgram(program, 0, NULL, NULL, NULL, NULL);
    if (err != CL_SUCCESS) {
        size_t len;
        char buffer[2048];
        clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, sizeof(buffer), buffer, &len);
        printf("%s\n", buffer);
        return EXIT_FAILURE;
    }

    // Extract the kernel (function) from the program (library)
    cl_kernel kernel_reduce = clCreateKernel(program, "reduce", &err);
    checkError(err, "Creating kernel");

    // Allocate memory for the partial sums on the device
    cl_mem d_partial_sums = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(int) * num_groups, NULL, &err);
    checkError(err, "Creating buffer d_partial_sums");

    // Set kernel arguments
    clSetKernelArg(kernel_reduce, 0, sizeof(cl_mem), (void *)&d_vec);
    clSetKernelArg(kernel_reduce, 1, sizeof(unsigned int), (void *)&n);
    clSetKernelArg(kernel_reduce, 2, sizeof(cl_mem), (void *)&d_partial_sums);

    // Set the local and global size
    size_t globalSize = (size_t)n;
    size_t localSize = (size_t)size_group;
    printf("Global size of kernel: %i\n", (int)globalSize);
    printf("Local size of kernel: %i\n", (int)localSize);

    // Run the kernel
    err = clEnqueueNDRangeKernel(commands, kernel_reduce, 1, NULL, &globalSize, &localSize, 0, NULL, NULL);
    checkError(err, "Enqueueing kernel");

    // One output per workgroup
    int *h_partial_sums = (int *)malloc(sizeof(int) * num_groups);
    err = clEnqueueReadBuffer(commands, d_partial_sums,	CL_TRUE, 0,	sizeof(int) * num_groups, h_partial_sums, 0, NULL, NULL);
    checkError(err, "Reading back d_partial_sums");

    // The final reduction putting the workgroup results
    // together is done by the CPU.
    unsigned int global_sum = 0;
    for (int i = 0; i < num_groups; i++)
        global_sum += h_partial_sums[i];
    printf("Calculated sum: %i\n", global_sum);
    printf("Exact value of sum: %i\n", (size_vector * (size_vector - 1)) / 2);

    // Shutdown and cleanup
    clReleaseMemObject(d_partial_sums);
    clReleaseProgram(program);
    clReleaseKernel(kernel_reduce);
    clReleaseCommandQueue(commands);
    clReleaseContext(context);
    clReleaseDevice(device);
    free(h_partial_sums);
    free(h_vec);
    free(vec_orig);

    return 0;
}
